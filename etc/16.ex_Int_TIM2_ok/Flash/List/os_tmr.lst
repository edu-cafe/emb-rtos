###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      23/Jun/2013  20:20:43 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Embedded2\현대모비스\RTOS_CM3\MyData\src_my\uCOS-II-M #
#                    32_ok\uCOS-II\Source\os_tmr.c                            #
#    Command line =  D:\Embedded2\현대모비스\RTOS_CM3\MyData\src_my\uCOS-II-M #
#                    32_ok\uCOS-II\Source\os_tmr.c -lCN                       #
#                    D:\Embedded2\현대모비스\RTOS_CM3\MyData\src_my\uCOS-II-M #
#                    32_ok\EvalBoards\ST\MANGO-Z1\IAR\16.ex_Int_TIM2\Flash\Li #
#                    st\ -o D:\Embedded2\현대모비스\RTOS_CM3\MyData\src_my\uC #
#                    OS-II-M32_ok\EvalBoards\ST\MANGO-Z1\IAR\16.ex_Int_TIM2\F #
#                    lash\Obj\ --no_cse --no_unroll --no_inline               #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I D:\Embedded2\현대모비스\RTOS_CM3\MyData\src_my #
#                    \uCOS-II-M32_ok\EvalBoards\ST\MANGO-Z1\IAR\16.ex_Int_TIM #
#                    2\ -I D:\Embedded2\현대모비스\RTOS_CM3\MyData\src_my\uCO #
#                    S-II-M32_ok\EvalBoards\ST\MANGO-Z1\IAR\16.ex_Int_TIM2\.. #
#                    \BSP\ -I D:\Embedded2\현대모비스\RTOS_CM3\MyData\src_my\ #
#                    uCOS-II-M32_ok\EvalBoards\ST\MANGO-Z1\IAR\16.ex_Int_TIM2 #
#                    \..\..\..\..\..\CPU\ST\STM32\inc\ -I                     #
#                    D:\Embedded2\현대모비스\RTOS_CM3\MyData\src_my\uCOS-II-M #
#                    32_ok\EvalBoards\ST\MANGO-Z1\IAR\16.ex_Int_TIM2\..\..\.. #
#                    \..\..\uC-CPU\ -I D:\Embedded2\현대모비스\RTOS_CM3\MyDat #
#                    a\src_my\uCOS-II-M32_ok\EvalBoards\ST\MANGO-Z1\IAR\16.ex #
#                    _Int_TIM2\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\ -I    #
#                    D:\Embedded2\현대모비스\RTOS_CM3\MyData\src_my\uCOS-II-M #
#                    32_ok\EvalBoards\ST\MANGO-Z1\IAR\16.ex_Int_TIM2\..\..\.. #
#                    \..\..\uC-LCD\Source\ -I D:\Embedded2\현대모비스\RTOS_CM #
#                    3\MyData\src_my\uCOS-II-M32_ok\EvalBoards\ST\MANGO-Z1\IA #
#                    R\16.ex_Int_TIM2\..\..\..\..\..\uC-LIB\ -I               #
#                    D:\Embedded2\현대모비스\RTOS_CM3\MyData\src_my\uCOS-II-M #
#                    32_ok\EvalBoards\ST\MANGO-Z1\IAR\16.ex_Int_TIM2\..\..\.. #
#                    \..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR\ -I       #
#                    D:\Embedded2\현대모비스\RTOS_CM3\MyData\src_my\uCOS-II-M #
#                    32_ok\EvalBoards\ST\MANGO-Z1\IAR\16.ex_Int_TIM2\..\..\.. #
#                    \..\..\uCOS-II\Source\ -I D:\Embedded2\현대모비스\RTOS_C #
#                    M3\MyData\src_my\uCOS-II-M32_ok\EvalBoards\ST\MANGO-Z1\I #
#                    AR\16.ex_Int_TIM2\..\..\..\..\..\uC-Probe\Target\Communi #
#                    cation\Generic\RS-232\Source\ -I                         #
#                    D:\Embedded2\현대모비스\RTOS_CM3\MyData\src_my\uCOS-II-M #
#                    32_ok\EvalBoards\ST\MANGO-Z1\IAR\16.ex_Int_TIM2\..\..\.. #
#                    \..\..\uC-Probe\Target\Communication\Generic\RS-232\Port #
#                    s\ST\STM32\ -I D:\Embedded2\현대모비스\RTOS_CM3\MyData\s #
#                    rc_my\uCOS-II-M32_ok\EvalBoards\ST\MANGO-Z1\IAR\16.ex_In #
#                    t_TIM2\..\..\..\..\..\uC-Probe\Target\Communication\Gene #
#                    ric\Source\ -I D:\Embedded2\현대모비스\RTOS_CM3\MyData\s #
#                    rc_my\uCOS-II-M32_ok\EvalBoards\ST\MANGO-Z1\IAR\16.ex_In #
#                    t_TIM2\..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II\   #
#                    -Ol --use_c++_inline                                     #
#    List file    =  D:\Embedded2\현대모비스\RTOS_CM3\MyData\src_my\uCOS-II-M #
#                    32_ok\EvalBoards\ST\MANGO-Z1\IAR\16.ex_Int_TIM2\Flash\Li #
#                    st\os_tmr.lst                                            #
#    Object file  =  D:\Embedded2\현대모비스\RTOS_CM3\MyData\src_my\uCOS-II-M #
#                    32_ok\EvalBoards\ST\MANGO-Z1\IAR\16.ex_Int_TIM2\Flash\Ob #
#                    j\os_tmr.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

D:\Embedded2\현대모비스\RTOS_CM3\MyData\src_my\uCOS-II-M32_ok\uCOS-II\Source\os_tmr.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                            TIMER MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2007, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          *
     11          * File    : OS_TMR.C
     12          * By      : Jean J. Labrosse
     13          * Version : V2.86
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
     18          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micri탆 to properly license 
     19          * its use in your product. We provide ALL the source code for your convenience and to help you experience 
     20          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
     21          * licensing fee.
     22          ************************************************************************************************************************
     23          */
     24          
     25          #include <ucos_ii.h>
     26          
     27          /*
     28          ************************************************************************************************************************
     29          *                                                        NOTES
     30          *
     31          * 1) Your application MUST define the following #define constants:
     32          *
     33          *    OS_TASK_TMR_PRIO          The priority of the Timer management task
     34          *    OS_TASK_TMR_STK_SIZE      The size     of the Timer management task's stack
     35          *
     36          * 2) You must call OSTmrSignal() to notify the Timer management task that it's time to update the timers.
     37          ************************************************************************************************************************
     38          */
     39          
     40          /*
     41          ************************************************************************************************************************
     42          *                                                     CONSTANTS
     43          ************************************************************************************************************************
     44          */
     45          
     46          #define  OS_TMR_LINK_DLY       0
     47          #define  OS_TMR_LINK_PERIODIC  1
     48          
     49          /*
     50          ************************************************************************************************************************
     51          *                                                  LOCAL PROTOTYPES
     52          ************************************************************************************************************************
     53          */
     54          
     55          #if OS_TMR_EN > 0
     56          static  OS_TMR  *OSTmr_Alloc         (void);
     57          static  void     OSTmr_Free          (OS_TMR *ptmr);
     58          static  void     OSTmr_InitTask      (void);
     59          static  void     OSTmr_Link          (OS_TMR *ptmr, INT8U type);
     60          static  void     OSTmr_Unlink        (OS_TMR *ptmr);
     61          static  void     OSTmr_Lock          (void);
     62          static  void     OSTmr_Unlock        (void);
     63          static  void     OSTmr_Task          (void   *p_arg);
     64          #endif
     65          
     66          /*$PAGE*/
     67          /*
     68          ************************************************************************************************************************
     69          *                                                   CREATE A TIMER
     70          *
     71          * Description: This function is called by your application code to create a timer.
     72          *
     73          * Arguments  : dly           Initial delay.
     74          *                            If the timer is configured for ONE-SHOT mode, this is the timeout used
     75          *                            If the timer is configured for PERIODIC mode, this is the first timeout to wait for
     76          *                               before the timer starts entering periodic mode
     77          *
     78          *              period        The 'period' being repeated for the timer.
     79          *                               If you specified 'OS_TMR_OPT_PERIODIC' as an option, when the timer expires, it will
     80          *                               automatically restart with the same period.
     81          *
     82          *              opt           Specifies either:
     83          *                               OS_TMR_OPT_ONE_SHOT       The timer counts down only once
     84          *                               OS_TMR_OPT_PERIODIC       The timer counts down and then reloads itself
     85          *
     86          *              callback      Is a pointer to a callback function that will be called when the timer expires.  The
     87          *                               callback function must be declared as follows:
     88          *
     89          *                               void MyCallback (OS_TMR *ptmr, void *p_arg);
     90          *
     91          *              callback_arg  Is an argument (a pointer) that is passed to the callback function when it is called.
     92          *
     93          *              pname         Is a pointer to an ASCII string that is used to name the timer.  Names are useful for
     94          *                               debugging.  The length of the ASCII string for the name can be as big as:
     95          *
     96          *                               OS_TMR_CFG_NAME_SIZE and should be found in OS_CFG.H
     97          *
     98          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
     99          *                               OS_ERR_NONE
    100          *                               OS_ERR_TMR_INVALID_DLY     you specified an invalid delay
    101          *                               OS_ERR_TMR_INVALID_PERIOD  you specified an invalid period
    102          *                               OS_ERR_TMR_INVALID_OPT     you specified an invalid option
    103          *                               OS_ERR_TMR_ISR             if the call was made from an ISR
    104          *                               OS_ERR_TMR_NON_AVAIL       if there are no free timers from the timer pool
    105          *                               OS_ERR_TMR_NAME_TOO_LONG   if the timer name is too long to fit
    106          *
    107          * Returns    : A pointer to an OS_TMR data structure.  
    108          *              This is the 'handle' that your application will use to reference the timer created.
    109          ************************************************************************************************************************
    110          */
    111          
    112          #if OS_TMR_EN > 0

   \                                 In section .text, align 2, keep-with-next
    113          OS_TMR  *OSTmrCreate (INT32U           dly,
    114                                INT32U           period,
    115                                INT8U            opt,
    116                                OS_TMR_CALLBACK  callback,
    117                                void            *callback_arg,
    118                                INT8U           *pname,
    119                                INT8U           *perr)
    120          {
   \                     OSTmrCreate:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x4699             MOV      R9,R3
   \   0000000C   0xF8DD 0xA020      LDR      R10,[SP, #+32]
   \   00000010   0x9C0A             LDR      R4,[SP, #+40]
    121              OS_TMR   *ptmr;
    122          #if OS_TMR_CFG_NAME_SIZE > 0
    123              INT8U     len;
    124          #endif
    125          
    126          
    127          #if OS_ARG_CHK_EN > 0
    128              if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
    129                  return ((OS_TMR *)0);
    130              }
    131              switch (opt) {
    132                  case OS_TMR_OPT_PERIODIC:
    133                       if (period == 0) {
    134                           *perr = OS_ERR_TMR_INVALID_PERIOD;
    135                           return ((OS_TMR *)0);
    136                       }
    137                       break;
    138          
    139                  case OS_TMR_OPT_ONE_SHOT:
    140                       if (dly == 0) {
    141                           *perr = OS_ERR_TMR_INVALID_DLY;
    142                           return ((OS_TMR *)0);
    143                       }
    144                       break;
    145          
    146                  default:
    147                       *perr = OS_ERR_TMR_INVALID_OPT;
    148                       return ((OS_TMR *)0);
    149              }
    150          #endif
    151              if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD003             BEQ.N    ??OSTmrCreate_0
    152                  *perr  = OS_ERR_TMR_ISR;
   \   0000001C   0x208B             MOVS     R0,#+139
   \   0000001E   0x7020             STRB     R0,[R4, #+0]
    153                  return ((OS_TMR *)0);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE02A             B.N      ??OSTmrCreate_1
    154              }
    155              OSTmr_Lock();
   \                     ??OSTmrCreate_0:
   \   00000024   0x.... 0x....      BL       OSTmr_Lock
    156              ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
   \   00000028   0x.... 0x....      BL       OSTmr_Alloc
   \   0000002C   0x0005             MOVS     R5,R0
    157              if (ptmr == (OS_TMR *)0) {
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD105             BNE.N    ??OSTmrCreate_2
    158                  OSTmr_Unlock();
   \   00000032   0x.... 0x....      BL       OSTmr_Unlock
    159                  *perr = OS_ERR_TMR_NON_AVAIL;
   \   00000036   0x2086             MOVS     R0,#+134
   \   00000038   0x7020             STRB     R0,[R4, #+0]
    160                  return ((OS_TMR *)0);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE01D             B.N      ??OSTmrCreate_1
    161              }
    162              ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
   \                     ??OSTmrCreate_2:
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xF885 0x0031      STRB     R0,[R5, #+49]
    163              ptmr->OSTmrDly         = dly;
   \   00000044   0x61AE             STR      R6,[R5, #+24]
    164              ptmr->OSTmrPeriod      = period;
   \   00000046   0x61EF             STR      R7,[R5, #+28]
    165              ptmr->OSTmrOpt         = opt;
   \   00000048   0xF885 0x8030      STRB     R8,[R5, #+48]
    166              ptmr->OSTmrCallback    = callback;
   \   0000004C   0xF8C5 0x9004      STR      R9,[R5, #+4]
    167              ptmr->OSTmrCallbackArg = callback_arg;
   \   00000050   0xF8C5 0xA008      STR      R10,[R5, #+8]
   \   00000054   0x9E09             LDR      R6,[SP, #+36]
    168          #if OS_TMR_CFG_NAME_SIZE > 0
    169              if (pname !=(INT8U *)0) {
   \   00000056   0x2E00             CMP      R6,#+0
   \   00000058   0xD00A             BEQ.N    ??OSTmrCreate_3
    170                  len = OS_StrLen(pname);                             /* Copy timer name                                        */
   \   0000005A   0x0030             MOVS     R0,R6
   \   0000005C   0x.... 0x....      BL       OS_StrLen
    171                  if (len < OS_TMR_CFG_NAME_SIZE) {
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0x2810             CMP      R0,#+16
   \   00000064   0xDA0B             BGE.N    ??OSTmrCreate_4
    172                      (void)OS_StrCopy(ptmr->OSTmrName, pname);
   \   00000066   0x0031             MOVS     R1,R6
   \   00000068   0xF115 0x0020      ADDS     R0,R5,#+32
   \   0000006C   0x.... 0x....      BL       OS_StrCopy
    173                  } else {
    174          #if OS_TMR_CFG_NAME_SIZE > 1
    175                      ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
    176                      ptmr->OSTmrName[1] = OS_ASCII_NUL;
    177          #endif
    178                      *perr              = OS_ERR_TMR_NAME_TOO_LONG;
    179                      OSTmr_Unlock();
    180                      return (ptmr);
    181                  }
    182              }
    183          #endif
    184              OSTmr_Unlock();
   \                     ??OSTmrCreate_3:
   \   00000070   0x.... 0x....      BL       OSTmr_Unlock
    185              *perr = OS_ERR_NONE;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x7020             STRB     R0,[R4, #+0]
    186              return (ptmr);
   \   00000078   0x0028             MOVS     R0,R5
   \                     ??OSTmrCreate_1:
   \   0000007A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \                     ??OSTmrCreate_4:
   \   0000007E   0x2023             MOVS     R0,#+35
   \   00000080   0xF885 0x0020      STRB     R0,[R5, #+32]
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xF885 0x0021      STRB     R0,[R5, #+33]
   \   0000008A   0x208C             MOVS     R0,#+140
   \   0000008C   0x7020             STRB     R0,[R4, #+0]
   \   0000008E   0x.... 0x....      BL       OSTmr_Unlock
   \   00000092   0x0028             MOVS     R0,R5
   \   00000094   0xE7F1             B.N      ??OSTmrCreate_1
    187          }
    188          #endif
    189          
    190          /*$PAGE*/
    191          /*
    192          ************************************************************************************************************************
    193          *                                                   DELETE A TIMER
    194          *
    195          * Description: This function is called by your application code to delete a timer.
    196          *
    197          * Arguments  : ptmr          Is a pointer to the timer to stop and delete.
    198          *
    199          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
    200          *                               OS_ERR_NONE
    201          *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
    202          *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
    203          *                               OS_ERR_TMR_ISR            if the function was called from an ISR
    204          *                               OS_ERR_TMR_INACTIVE       if the timer was not created
    205          *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
    206          *
    207          * Returns    : OS_TRUE       If the call was successful
    208          *              OS_FALSE      If not
    209          ************************************************************************************************************************
    210          */
    211          
    212          #if OS_TMR_EN > 0

   \                                 In section .text, align 2, keep-with-next
    213          BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
    214                             INT8U   *perr)
    215          {
   \                     OSTmrDel:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    216          #if OS_ARG_CHK_EN > 0
    217              if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
    218                  return (OS_FALSE);
    219              }
    220              if (ptmr == (OS_TMR *)0) {
    221                  *perr = OS_ERR_TMR_INVALID;
    222                  return (OS_FALSE);
    223              }
    224          #endif
    225              if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
   \   00000006   0x7828             LDRB     R0,[R5, #+0]
   \   00000008   0x2864             CMP      R0,#+100
   \   0000000A   0xD003             BEQ.N    ??OSTmrDel_0
    226                  *perr = OS_ERR_TMR_INVALID_TYPE;
   \   0000000C   0x2089             MOVS     R0,#+137
   \   0000000E   0x7020             STRB     R0,[R4, #+0]
    227                  return (OS_FALSE);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE033             B.N      ??OSTmrDel_1
    228              }
    229              if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
   \                     ??OSTmrDel_0:
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD003             BEQ.N    ??OSTmrDel_2
    230                  *perr  = OS_ERR_TMR_ISR;
   \   0000001E   0x208B             MOVS     R0,#+139
   \   00000020   0x7020             STRB     R0,[R4, #+0]
    231                  return (OS_FALSE);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE02A             B.N      ??OSTmrDel_1
    232              }
    233              OSTmr_Lock();
   \                     ??OSTmrDel_2:
   \   00000026   0x.... 0x....      BL       OSTmr_Lock
    234              switch (ptmr->OSTmrState) {
   \   0000002A   0xF895 0x0031      LDRB     R0,[R5, #+49]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD019             BEQ.N    ??OSTmrDel_3
   \   00000032   0x2802             CMP      R0,#+2
   \   00000034   0xD00E             BEQ.N    ??OSTmrDel_4
   \   00000036   0xD30D             BCC.N    ??OSTmrDel_4
   \   00000038   0x2803             CMP      R0,#+3
   \   0000003A   0xD11A             BNE.N    ??OSTmrDel_5
    235                  case OS_TMR_STATE_RUNNING:
    236                       OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
   \                     ??OSTmrDel_6:
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0x.... 0x....      BL       OSTmr_Unlink
    237                       OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
   \   00000042   0x0028             MOVS     R0,R5
   \   00000044   0x.... 0x....      BL       OSTmr_Free
    238                       OSTmr_Unlock();
   \   00000048   0x.... 0x....      BL       OSTmr_Unlock
    239                       *perr = OS_ERR_NONE;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x7020             STRB     R0,[R4, #+0]
    240                       return (OS_TRUE);
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xE013             B.N      ??OSTmrDel_1
    241          
    242                  case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
    243                  case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
    244                       OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
   \                     ??OSTmrDel_4:
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0x.... 0x....      BL       OSTmr_Free
    245                       OSTmr_Unlock();
   \   0000005A   0x.... 0x....      BL       OSTmr_Unlock
    246                       *perr = OS_ERR_NONE;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x7020             STRB     R0,[R4, #+0]
    247                       return (OS_TRUE);
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xE00A             B.N      ??OSTmrDel_1
    248          
    249                  case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
    250                       OSTmr_Unlock();
   \                     ??OSTmrDel_3:
   \   00000066   0x.... 0x....      BL       OSTmr_Unlock
    251                       *perr = OS_ERR_TMR_INACTIVE;
   \   0000006A   0x2087             MOVS     R0,#+135
   \   0000006C   0x7020             STRB     R0,[R4, #+0]
    252                       return (OS_FALSE);
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xE004             B.N      ??OSTmrDel_1
    253          
    254                  default:
    255                       OSTmr_Unlock();
   \                     ??OSTmrDel_5:
   \   00000072   0x.... 0x....      BL       OSTmr_Unlock
    256                       *perr = OS_ERR_TMR_INVALID_STATE;
   \   00000076   0x208D             MOVS     R0,#+141
   \   00000078   0x7020             STRB     R0,[R4, #+0]
    257                       return (OS_FALSE);
   \   0000007A   0x2000             MOVS     R0,#+0
   \                     ??OSTmrDel_1:
   \   0000007C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    258              }
    259          }
    260          #endif
    261          
    262          /*$PAGE*/
    263          /*
    264          ************************************************************************************************************************
    265          *                                             GET THE NAME OF A TIMER
    266          *
    267          * Description: This function is called to obtain the name of a timer.
    268          *
    269          * Arguments  : ptmr          Is a pointer to the timer to obtain the name for
    270          *
    271          *              pdest         Is a pointer to where the name of the timer will be placed.  It is the caller's responsibility
    272          *                            to ensure that he has sufficient storage in the destination, i.e. at least OS_TMR_CFG_NAME_SIZE
    273          *
    274          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
    275          *                               OS_ERR_NONE               The call was successful
    276          *                               OS_ERR_TMR_INVALID_DEST   'pdest' is a NULL pointer
    277          *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
    278          *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
    279          *                               OS_ERR_NAME_GET_ISR       if the call was made from an ISR
    280          *                               OS_ERR_TMR_INACTIVE       'ptmr'  points to a timer that is not active
    281          *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
    282          *
    283          * Returns    : The length of the string or 0 if the timer does not exist.
    284          ************************************************************************************************************************
    285          */
    286          
    287          #if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0

   \                                 In section .text, align 2, keep-with-next
    288          INT8U  OSTmrNameGet (OS_TMR  *ptmr,
    289                               INT8U   *pdest,
    290                               INT8U   *perr)
    291          {
   \                     OSTmrNameGet:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0014             MOVS     R4,R2
    292              INT8U  len;
    293          
    294          
    295          #if OS_ARG_CHK_EN > 0
    296              if (perr == (INT8U *)0) {
    297                  return (0);
    298              }
    299              if (pdest == (INT8U *)0) {
    300                  *perr = OS_ERR_TMR_INVALID_DEST;
    301                  return (0);
    302              }
    303              if (ptmr == (OS_TMR *)0) {
    304                  *perr = OS_ERR_TMR_INVALID;
    305                  return (0);
    306              }
    307          #endif
    308              if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
   \   00000008   0x7828             LDRB     R0,[R5, #+0]
   \   0000000A   0x2864             CMP      R0,#+100
   \   0000000C   0xD003             BEQ.N    ??OSTmrNameGet_0
    309                  *perr = OS_ERR_TMR_INVALID_TYPE;
   \   0000000E   0x2089             MOVS     R0,#+137
   \   00000010   0x7020             STRB     R0,[R4, #+0]
    310                  return (0);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE029             B.N      ??OSTmrNameGet_1
    311              }
    312              if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
   \                     ??OSTmrNameGet_0:
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD003             BEQ.N    ??OSTmrNameGet_2
    313                  *perr = OS_ERR_NAME_GET_ISR;
   \   00000020   0x2011             MOVS     R0,#+17
   \   00000022   0x7020             STRB     R0,[R4, #+0]
    314                  return (0);
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE020             B.N      ??OSTmrNameGet_1
    315              }
    316              OSTmr_Lock();
   \                     ??OSTmrNameGet_2:
   \   00000028   0x.... 0x....      BL       OSTmr_Lock
    317              switch (ptmr->OSTmrState) {
   \   0000002C   0xF895 0x0031      LDRB     R0,[R5, #+49]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD00F             BEQ.N    ??OSTmrNameGet_3
   \   00000034   0x1E40             SUBS     R0,R0,#+1
   \   00000036   0x2802             CMP      R0,#+2
   \   00000038   0xD812             BHI.N    ??OSTmrNameGet_4
    318                  case OS_TMR_STATE_RUNNING:
    319                  case OS_TMR_STATE_STOPPED:
    320                  case OS_TMR_STATE_COMPLETED:
    321                       len   = OS_StrCopy(pdest, ptmr->OSTmrName);
   \                     ??OSTmrNameGet_5:
   \   0000003A   0xF115 0x0120      ADDS     R1,R5,#+32
   \   0000003E   0x0030             MOVS     R0,R6
   \   00000040   0x.... 0x....      BL       OS_StrCopy
   \   00000044   0x0005             MOVS     R5,R0
    322                       OSTmr_Unlock();
   \   00000046   0x.... 0x....      BL       OSTmr_Unlock
    323                       *perr = OS_ERR_NONE;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x7020             STRB     R0,[R4, #+0]
    324                       return (len);
   \   0000004E   0x0028             MOVS     R0,R5
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0xE00A             B.N      ??OSTmrNameGet_1
    325          
    326                  case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
    327                       OSTmr_Unlock();
   \                     ??OSTmrNameGet_3:
   \   00000054   0x.... 0x....      BL       OSTmr_Unlock
    328                       *perr = OS_ERR_TMR_INACTIVE;
   \   00000058   0x2087             MOVS     R0,#+135
   \   0000005A   0x7020             STRB     R0,[R4, #+0]
    329                       return (0);
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xE004             B.N      ??OSTmrNameGet_1
    330          
    331                  default:
    332                       OSTmr_Unlock();
   \                     ??OSTmrNameGet_4:
   \   00000060   0x.... 0x....      BL       OSTmr_Unlock
    333                       *perr = OS_ERR_TMR_INVALID_STATE;
   \   00000064   0x208D             MOVS     R0,#+141
   \   00000066   0x7020             STRB     R0,[R4, #+0]
    334                       return (0);
   \   00000068   0x2000             MOVS     R0,#+0
   \                     ??OSTmrNameGet_1:
   \   0000006A   0xBD70             POP      {R4-R6,PC}       ;; return
    335              }
    336          }
    337          #endif
    338          
    339          /*$PAGE*/
    340          /*
    341          ************************************************************************************************************************
    342          *                                    GET HOW MUCH TIME IS LEFT BEFORE A TIMER EXPIRES
    343          *
    344          * Description: This function is called to get the number of ticks before a timer times out.
    345          *
    346          * Arguments  : ptmr          Is a pointer to the timer to obtain the remaining time from.
    347          *
    348          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
    349          *                               OS_ERR_NONE
    350          *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
    351          *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
    352          *                               OS_ERR_TMR_ISR            if the call was made from an ISR
    353          *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
    354          *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
    355          *
    356          * Returns    : The time remaining for the timer to expire.  The time represents 'timer' increments.  In other words, if
    357          *              OSTmr_Task() is signaled every 1/10 of a second then the returned value represents the number of 1/10 of
    358          *              a second remaining before the timer expires.
    359          ************************************************************************************************************************
    360          */
    361          
    362          #if OS_TMR_EN > 0

   \                                 In section .text, align 2, keep-with-next
    363          INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
    364                                  INT8U   *perr)
    365          {
   \                     OSTmrRemainGet:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    366              INT32U  remain;
    367          
    368          
    369          #if OS_ARG_CHK_EN > 0
    370              if (perr == (INT8U *)0) {
    371                  return (0);
    372              }
    373              if (ptmr == (OS_TMR *)0) {
    374                  *perr = OS_ERR_TMR_INVALID;
    375                  return (0);
    376              }
    377          #endif
    378              if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
   \   00000006   0x7828             LDRB     R0,[R5, #+0]
   \   00000008   0x2864             CMP      R0,#+100
   \   0000000A   0xD003             BEQ.N    ??OSTmrRemainGet_0
    379                  *perr = OS_ERR_TMR_INVALID_TYPE;
   \   0000000C   0x2089             MOVS     R0,#+137
   \   0000000E   0x7020             STRB     R0,[R4, #+0]
    380                  return (0);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE045             B.N      ??OSTmrRemainGet_1
    381              }
    382              if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
   \                     ??OSTmrRemainGet_0:
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD003             BEQ.N    ??OSTmrRemainGet_2
    383                  *perr = OS_ERR_TMR_ISR;
   \   0000001E   0x208B             MOVS     R0,#+139
   \   00000020   0x7020             STRB     R0,[R4, #+0]
    384                  return (0);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE03C             B.N      ??OSTmrRemainGet_1
    385              }
    386              OSTmr_Lock();
   \                     ??OSTmrRemainGet_2:
   \   00000026   0x.... 0x....      BL       OSTmr_Lock
    387              switch (ptmr->OSTmrState) {
   \   0000002A   0xF895 0x0031      LDRB     R0,[R5, #+49]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD02B             BEQ.N    ??OSTmrRemainGet_3
   \   00000032   0x2802             CMP      R0,#+2
   \   00000034   0xD023             BEQ.N    ??OSTmrRemainGet_4
   \   00000036   0xD30C             BCC.N    ??OSTmrRemainGet_5
   \   00000038   0x2803             CMP      R0,#+3
   \   0000003A   0xD12C             BNE.N    ??OSTmrRemainGet_6
    388                  case OS_TMR_STATE_RUNNING:
    389                       remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
   \                     ??OSTmrRemainGet_7:
   \   0000003C   0x6968             LDR      R0,[R5, #+20]
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   00000042   0x6809             LDR      R1,[R1, #+0]
   \   00000044   0x1A45             SUBS     R5,R0,R1
    390                       OSTmr_Unlock();
   \   00000046   0x.... 0x....      BL       OSTmr_Unlock
    391                       *perr  = OS_ERR_NONE;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x7020             STRB     R0,[R4, #+0]
    392                       return (remain);
   \   0000004E   0x0028             MOVS     R0,R5
   \   00000050   0xE026             B.N      ??OSTmrRemainGet_1
    393          
    394                  case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
    395                       switch (ptmr->OSTmrOpt) {
   \                     ??OSTmrRemainGet_5:
   \   00000052   0xF895 0x0030      LDRB     R0,[R5, #+48]
   \   00000056   0x2802             CMP      R0,#+2
   \   00000058   0xD10A             BNE.N    ??OSTmrRemainGet_8
    396                           case OS_TMR_OPT_PERIODIC:
    397                                if (ptmr->OSTmrDly == 0) {
   \   0000005A   0x69A8             LDR      R0,[R5, #+24]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD101             BNE.N    ??OSTmrRemainGet_9
    398                                    remain = ptmr->OSTmrPeriod;
   \   00000060   0x69ED             LDR      R5,[R5, #+28]
   \   00000062   0xE000             B.N      ??OSTmrRemainGet_10
    399                                } else {
    400                                    remain = ptmr->OSTmrDly;
   \                     ??OSTmrRemainGet_9:
   \   00000064   0x69AD             LDR      R5,[R5, #+24]
    401                                }
    402                                OSTmr_Unlock();
   \                     ??OSTmrRemainGet_10:
   \   00000066   0x.... 0x....      BL       OSTmr_Unlock
    403                                *perr  = OS_ERR_NONE;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x7020             STRB     R0,[R4, #+0]
    404                                break;
   \   0000006E   0xE004             B.N      ??OSTmrRemainGet_11
    405          
    406                           case OS_TMR_OPT_ONE_SHOT:
    407                           default:
    408                                remain = ptmr->OSTmrDly;
   \                     ??OSTmrRemainGet_8:
   \   00000070   0x69AD             LDR      R5,[R5, #+24]
    409                                OSTmr_Unlock();
   \   00000072   0x.... 0x....      BL       OSTmr_Unlock
    410                                *perr  = OS_ERR_NONE;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x7020             STRB     R0,[R4, #+0]
    411                                break;
    412                       }
    413                       return (remain);
   \                     ??OSTmrRemainGet_11:
   \   0000007A   0x0028             MOVS     R0,R5
   \   0000007C   0xE010             B.N      ??OSTmrRemainGet_1
    414          
    415                  case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
    416                       OSTmr_Unlock();
   \                     ??OSTmrRemainGet_4:
   \   0000007E   0x.... 0x....      BL       OSTmr_Unlock
    417                       *perr = OS_ERR_NONE;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x7020             STRB     R0,[R4, #+0]
    418                       return (0);
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xE00A             B.N      ??OSTmrRemainGet_1
    419          
    420                  case OS_TMR_STATE_UNUSED:
    421                       OSTmr_Unlock();
   \                     ??OSTmrRemainGet_3:
   \   0000008A   0x.... 0x....      BL       OSTmr_Unlock
    422                       *perr = OS_ERR_TMR_INACTIVE;
   \   0000008E   0x2087             MOVS     R0,#+135
   \   00000090   0x7020             STRB     R0,[R4, #+0]
    423                       return (0);
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xE004             B.N      ??OSTmrRemainGet_1
    424          
    425                  default:
    426                       OSTmr_Unlock();
   \                     ??OSTmrRemainGet_6:
   \   00000096   0x.... 0x....      BL       OSTmr_Unlock
    427                       *perr = OS_ERR_TMR_INVALID_STATE;
   \   0000009A   0x208D             MOVS     R0,#+141
   \   0000009C   0x7020             STRB     R0,[R4, #+0]
    428                       return (0);
   \   0000009E   0x2000             MOVS     R0,#+0
   \                     ??OSTmrRemainGet_1:
   \   000000A0   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    429              }
    430          }
    431          #endif
    432          
    433          /*$PAGE*/
    434          /*
    435          ************************************************************************************************************************
    436          *                                    FIND OUT WHAT STATE A TIMER IS IN
    437          *
    438          * Description: This function is called to determine what state the timer is in:
    439          *
    440          *                  OS_TMR_STATE_UNUSED     the timer has not been created
    441          *                  OS_TMR_STATE_STOPPED    the timer has been created but has not been started or has been stopped
    442          *                  OS_TMR_COMPLETED        the timer is in ONE-SHOT mode and has completed it's timeout
    443          *                  OS_TMR_RUNNING          the timer is currently running
    444          *
    445          * Arguments  : ptmr          Is a pointer to the desired timer
    446          *
    447          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
    448          *                               OS_ERR_NONE
    449          *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
    450          *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
    451          *                               OS_ERR_TMR_ISR            if the call was made from an ISR
    452          *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
    453          *                               OS_ERR_TMR_INVALID_STATE  if the timer is not in a valid state
    454          *
    455          * Returns    : The current state of the timer (see description).
    456          ************************************************************************************************************************
    457          */
    458          
    459          #if OS_TMR_EN > 0

   \                                 In section .text, align 2, keep-with-next
    460          INT8U  OSTmrStateGet (OS_TMR  *ptmr,
    461                                INT8U   *perr)
    462          {
   \                     OSTmrStateGet:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    463              INT8U  state;
    464          
    465          
    466          #if OS_ARG_CHK_EN > 0
    467              if (perr == (INT8U *)0) {
    468                  return (0);
    469              }
    470              if (ptmr == (OS_TMR *)0) {
    471                  *perr = OS_ERR_TMR_INVALID;
    472                  return (0);
    473              }
    474          #endif
    475              if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
   \   00000006   0x7828             LDRB     R0,[R5, #+0]
   \   00000008   0x2864             CMP      R0,#+100
   \   0000000A   0xD003             BEQ.N    ??OSTmrStateGet_0
    476                  *perr = OS_ERR_TMR_INVALID_TYPE;
   \   0000000C   0x2089             MOVS     R0,#+137
   \   0000000E   0x7020             STRB     R0,[R4, #+0]
    477                  return (0);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE01A             B.N      ??OSTmrStateGet_1
    478              }
    479              if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
   \                     ??OSTmrStateGet_0:
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD003             BEQ.N    ??OSTmrStateGet_2
    480                  *perr = OS_ERR_TMR_ISR;
   \   0000001E   0x208B             MOVS     R0,#+139
   \   00000020   0x7020             STRB     R0,[R4, #+0]
    481                  return (0);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE011             B.N      ??OSTmrStateGet_1
    482              }
    483              OSTmr_Lock();
   \                     ??OSTmrStateGet_2:
   \   00000026   0x.... 0x....      BL       OSTmr_Lock
    484              state = ptmr->OSTmrState;
   \   0000002A   0xF895 0x5031      LDRB     R5,[R5, #+49]
    485              switch (state) {
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0x2803             CMP      R0,#+3
   \   00000036   0xD802             BHI.N    ??OSTmrStateGet_3
    486                  case OS_TMR_STATE_UNUSED:   
    487                  case OS_TMR_STATE_STOPPED:  
    488                  case OS_TMR_STATE_COMPLETED:
    489                  case OS_TMR_STATE_RUNNING:  
    490                       *perr = OS_ERR_NONE;
   \                     ??OSTmrStateGet_4:
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7020             STRB     R0,[R4, #+0]
    491                       break;
   \   0000003C   0xE001             B.N      ??OSTmrStateGet_5
    492                       
    493                  default:
    494                       *perr = OS_ERR_TMR_INVALID_STATE;
   \                     ??OSTmrStateGet_3:
   \   0000003E   0x208D             MOVS     R0,#+141
   \   00000040   0x7020             STRB     R0,[R4, #+0]
    495                       break;
    496              }
    497              OSTmr_Unlock();
   \                     ??OSTmrStateGet_5:
   \   00000042   0x.... 0x....      BL       OSTmr_Unlock
    498              return (state);
   \   00000046   0x0028             MOVS     R0,R5
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??OSTmrStateGet_1:
   \   0000004A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    499          }
    500          #endif
    501          
    502          /*$PAGE*/
    503          /*
    504          ************************************************************************************************************************
    505          *                                                   START A TIMER
    506          *
    507          * Description: This function is called by your application code to start a timer.
    508          *
    509          * Arguments  : ptmr          Is a pointer to an OS_TMR
    510          *
    511          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
    512          *                               OS_ERR_NONE
    513          *                               OS_ERR_TMR_INVALID
    514          *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
    515          *                               OS_ERR_TMR_ISR             if the call was made from an ISR
    516          *                               OS_ERR_TMR_INACTIVE        if the timer was not created
    517          *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
    518          *
    519          * Returns    : OS_TRUE    if the timer was started
    520          *              OS_FALSE   if an error was detected
    521          ************************************************************************************************************************
    522          */
    523          
    524          #if OS_TMR_EN > 0

   \                                 In section .text, align 2, keep-with-next
    525          BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
    526                               INT8U    *perr)
    527          {
   \                     OSTmrStart:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    528          #if OS_ARG_CHK_EN > 0
    529              if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
    530                  return (OS_FALSE);
    531              }
    532              if (ptmr == (OS_TMR *)0) {
    533                  *perr = OS_ERR_TMR_INVALID;
    534                  return (OS_FALSE);
    535              }
    536          #endif
    537              if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
   \   00000006   0x7828             LDRB     R0,[R5, #+0]
   \   00000008   0x2864             CMP      R0,#+100
   \   0000000A   0xD003             BEQ.N    ??OSTmrStart_0
    538                  *perr = OS_ERR_TMR_INVALID_TYPE;
   \   0000000C   0x2089             MOVS     R0,#+137
   \   0000000E   0x7020             STRB     R0,[R4, #+0]
    539                  return (OS_FALSE);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE035             B.N      ??OSTmrStart_1
    540              }
    541              if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
   \                     ??OSTmrStart_0:
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD003             BEQ.N    ??OSTmrStart_2
    542                  *perr  = OS_ERR_TMR_ISR;
   \   0000001E   0x208B             MOVS     R0,#+139
   \   00000020   0x7020             STRB     R0,[R4, #+0]
    543                  return (OS_FALSE);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE02C             B.N      ??OSTmrStart_1
    544              }
    545              OSTmr_Lock();
   \                     ??OSTmrStart_2:
   \   00000026   0x.... 0x....      BL       OSTmr_Lock
    546              switch (ptmr->OSTmrState) {
   \   0000002A   0xF895 0x0031      LDRB     R0,[R5, #+49]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD01B             BEQ.N    ??OSTmrStart_3
   \   00000032   0x2802             CMP      R0,#+2
   \   00000034   0xD00F             BEQ.N    ??OSTmrStart_4
   \   00000036   0xD30E             BCC.N    ??OSTmrStart_4
   \   00000038   0x2803             CMP      R0,#+3
   \   0000003A   0xD11C             BNE.N    ??OSTmrStart_5
    547                  case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
    548                       OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
   \                     ??OSTmrStart_6:
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0x.... 0x....      BL       OSTmr_Unlink
    549                       OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x0028             MOVS     R0,R5
   \   00000046   0x.... 0x....      BL       OSTmr_Link
    550                       OSTmr_Unlock();
   \   0000004A   0x.... 0x....      BL       OSTmr_Unlock
    551                       *perr = OS_ERR_NONE;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x7020             STRB     R0,[R4, #+0]
    552                       return (OS_TRUE);
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xE014             B.N      ??OSTmrStart_1
    553          
    554                  case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
    555                  case OS_TMR_STATE_COMPLETED:
    556                       OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
   \                     ??OSTmrStart_4:
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x0028             MOVS     R0,R5
   \   0000005A   0x.... 0x....      BL       OSTmr_Link
    557                       OSTmr_Unlock();
   \   0000005E   0x.... 0x....      BL       OSTmr_Unlock
    558                       *perr = OS_ERR_NONE;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x7020             STRB     R0,[R4, #+0]
    559                       return (OS_TRUE);
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xE00A             B.N      ??OSTmrStart_1
    560          
    561                  case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
    562                       OSTmr_Unlock();
   \                     ??OSTmrStart_3:
   \   0000006A   0x.... 0x....      BL       OSTmr_Unlock
    563                       *perr = OS_ERR_TMR_INACTIVE;
   \   0000006E   0x2087             MOVS     R0,#+135
   \   00000070   0x7020             STRB     R0,[R4, #+0]
    564                       return (OS_FALSE);
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xE004             B.N      ??OSTmrStart_1
    565          
    566                  default:
    567                       OSTmr_Unlock();
   \                     ??OSTmrStart_5:
   \   00000076   0x.... 0x....      BL       OSTmr_Unlock
    568                       *perr = OS_ERR_TMR_INVALID_STATE;
   \   0000007A   0x208D             MOVS     R0,#+141
   \   0000007C   0x7020             STRB     R0,[R4, #+0]
    569                       return (OS_FALSE);
   \   0000007E   0x2000             MOVS     R0,#+0
   \                     ??OSTmrStart_1:
   \   00000080   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    570              }
    571          }
    572          #endif
    573          
    574          /*$PAGE*/
    575          /*
    576          ************************************************************************************************************************
    577          *                                                   STOP A TIMER
    578          *
    579          * Description: This function is called by your application code to stop a timer.
    580          *
    581          * Arguments  : ptmr          Is a pointer to the timer to stop.
    582          *
    583          *              opt           Allows you to specify an option to this functions which can be:
    584          *
    585          *                               OS_TMR_OPT_NONE          Do nothing special but stop the timer
    586          *                               OS_TMR_OPT_CALLBACK      Execute the callback function, pass it the callback argument
    587          *                                                        specified when the timer was created.
    588          *                               OS_TMR_OPT_CALLBACK_ARG  Execute the callback function, pass it the callback argument
    589          *                                                        specified in THIS function call
    590          *
    591          *              callback_arg  Is a pointer to a 'new' callback argument that can be passed to the callback function
    592          *                               instead of the timer's callback argument.  In other words, use 'callback_arg' passed in
    593          *                               THIS function INSTEAD of ptmr->OSTmrCallbackArg
    594          *
    595          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
    596          *                               OS_ERR_NONE
    597          *                               OS_ERR_TMR_INVALID         'ptmr' is a NULL pointer
    598          *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
    599          *                               OS_ERR_TMR_ISR             if the function was called from an ISR
    600          *                               OS_ERR_TMR_INACTIVE        if the timer was not created
    601          *                               OS_ERR_TMR_INVALID_OPT     if you specified an invalid option for 'opt'
    602          *                               OS_ERR_TMR_STOPPED         if the timer was already stopped
    603          *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
    604          *                               OS_ERR_TMR_NO_CALLBACK     if the timer does not have a callback function defined
    605          *
    606          * Returns    : OS_TRUE       If we stopped the timer (if the timer is already stopped, we also return OS_TRUE)
    607          *              OS_FALSE      If not
    608          ************************************************************************************************************************
    609          */
    610          
    611          #if OS_TMR_EN > 0

   \                                 In section .text, align 2, keep-with-next
    612          BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
    613                              INT8U    opt,
    614                              void    *callback_arg,
    615                              INT8U   *perr)
    616          {
   \                     OSTmrStop:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001C             MOVS     R4,R3
    617              OS_TMR_CALLBACK  pfnct;
    618          
    619          
    620          #if OS_ARG_CHK_EN > 0
    621              if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
    622                  return (OS_FALSE);
    623              }
    624              if (ptmr == (OS_TMR *)0) {
    625                  *perr = OS_ERR_TMR_INVALID;
    626                  return (OS_FALSE);
    627              }
    628          #endif
    629              if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
   \   0000000A   0x7828             LDRB     R0,[R5, #+0]
   \   0000000C   0x2864             CMP      R0,#+100
   \   0000000E   0xD003             BEQ.N    ??OSTmrStop_0
    630                  *perr = OS_ERR_TMR_INVALID_TYPE;
   \   00000010   0x2089             MOVS     R0,#+137
   \   00000012   0x7020             STRB     R0,[R4, #+0]
    631                  return (OS_FALSE);
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE04E             B.N      ??OSTmrStop_1
    632              }
    633              if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
   \                     ??OSTmrStop_0:
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD003             BEQ.N    ??OSTmrStop_2
    634                  *perr  = OS_ERR_TMR_ISR;
   \   00000022   0x208B             MOVS     R0,#+139
   \   00000024   0x7020             STRB     R0,[R4, #+0]
    635                  return (OS_FALSE);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE045             B.N      ??OSTmrStop_1
    636              }
    637              OSTmr_Lock();
   \                     ??OSTmrStop_2:
   \   0000002A   0x.... 0x....      BL       OSTmr_Lock
    638              switch (ptmr->OSTmrState) {
   \   0000002E   0xF895 0x0031      LDRB     R0,[R5, #+49]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD034             BEQ.N    ??OSTmrStop_3
   \   00000036   0x2802             CMP      R0,#+2
   \   00000038   0xD02C             BEQ.N    ??OSTmrStop_4
   \   0000003A   0xD32B             BCC.N    ??OSTmrStop_4
   \   0000003C   0x2803             CMP      R0,#+3
   \   0000003E   0xD135             BNE.N    ??OSTmrStop_5
    639                  case OS_TMR_STATE_RUNNING:
    640                       OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
   \                     ??OSTmrStop_6:
   \   00000040   0x0028             MOVS     R0,R5
   \   00000042   0x.... 0x....      BL       OSTmr_Unlink
    641                       *perr = OS_ERR_NONE;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x7020             STRB     R0,[R4, #+0]
    642                       switch (opt) {
   \   0000004A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000004C   0x2F00             CMP      R7,#+0
   \   0000004E   0xD01A             BEQ.N    ??OSTmrStop_7
   \   00000050   0x2F03             CMP      R7,#+3
   \   00000052   0xD002             BEQ.N    ??OSTmrStop_8
   \   00000054   0x2F04             CMP      R7,#+4
   \   00000056   0xD00B             BEQ.N    ??OSTmrStop_9
   \   00000058   0xE016             B.N      ??OSTmrStop_10
    643                           case OS_TMR_OPT_CALLBACK:
    644                                pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
   \                     ??OSTmrStop_8:
   \   0000005A   0x686A             LDR      R2,[R5, #+4]
    645                                if (pfnct != (OS_TMR_CALLBACK)0) {
   \   0000005C   0x0010             MOVS     R0,R2
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD003             BEQ.N    ??OSTmrStop_11
    646                                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
   \   00000062   0x68A9             LDR      R1,[R5, #+8]
   \   00000064   0x0028             MOVS     R0,R5
   \   00000066   0x4790             BLX      R2
   \   00000068   0xE001             B.N      ??OSTmrStop_12
    647                                } else {
    648                                    *perr = OS_ERR_TMR_NO_CALLBACK;
   \                     ??OSTmrStop_11:
   \   0000006A   0x208F             MOVS     R0,#+143
   \   0000006C   0x7020             STRB     R0,[R4, #+0]
    649                                }
    650                                break;
   \                     ??OSTmrStop_12:
   \   0000006E   0xE00D             B.N      ??OSTmrStop_13
    651          
    652                           case OS_TMR_OPT_CALLBACK_ARG:
    653                                pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
   \                     ??OSTmrStop_9:
   \   00000070   0x686A             LDR      R2,[R5, #+4]
    654                                if (pfnct != (OS_TMR_CALLBACK)0) {
   \   00000072   0x0010             MOVS     R0,R2
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD003             BEQ.N    ??OSTmrStop_14
    655                                    (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
   \   00000078   0x0031             MOVS     R1,R6
   \   0000007A   0x0028             MOVS     R0,R5
   \   0000007C   0x4790             BLX      R2
   \   0000007E   0xE001             B.N      ??OSTmrStop_15
    656                                } else {
    657                                    *perr = OS_ERR_TMR_NO_CALLBACK;
   \                     ??OSTmrStop_14:
   \   00000080   0x208F             MOVS     R0,#+143
   \   00000082   0x7020             STRB     R0,[R4, #+0]
    658                                }
    659                                break;
   \                     ??OSTmrStop_15:
   \   00000084   0xE002             B.N      ??OSTmrStop_13
    660          
    661                           case OS_TMR_OPT_NONE:
    662                                break;
   \                     ??OSTmrStop_7:
   \   00000086   0xE001             B.N      ??OSTmrStop_13
    663          
    664                           default:
    665                               *perr = OS_ERR_TMR_INVALID_OPT;
   \                     ??OSTmrStop_10:
   \   00000088   0x2084             MOVS     R0,#+132
   \   0000008A   0x7020             STRB     R0,[R4, #+0]
    666                               break;
    667                       }
    668                       OSTmr_Unlock();
   \                     ??OSTmrStop_13:
   \   0000008C   0x.... 0x....      BL       OSTmr_Unlock
    669                       return (OS_TRUE);
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0xE010             B.N      ??OSTmrStop_1
    670          
    671                  case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
    672                  case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
    673                       OSTmr_Unlock();
   \                     ??OSTmrStop_4:
   \   00000094   0x.... 0x....      BL       OSTmr_Unlock
    674                       *perr = OS_ERR_TMR_STOPPED;
   \   00000098   0x208E             MOVS     R0,#+142
   \   0000009A   0x7020             STRB     R0,[R4, #+0]
    675                       return (OS_TRUE);
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0xE00A             B.N      ??OSTmrStop_1
    676          
    677                  case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
    678                       OSTmr_Unlock();
   \                     ??OSTmrStop_3:
   \   000000A0   0x.... 0x....      BL       OSTmr_Unlock
    679                       *perr = OS_ERR_TMR_INACTIVE;
   \   000000A4   0x2087             MOVS     R0,#+135
   \   000000A6   0x7020             STRB     R0,[R4, #+0]
    680                       return (OS_FALSE);
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xE004             B.N      ??OSTmrStop_1
    681          
    682                  default:
    683                       OSTmr_Unlock();
   \                     ??OSTmrStop_5:
   \   000000AC   0x.... 0x....      BL       OSTmr_Unlock
    684                       *perr = OS_ERR_TMR_INVALID_STATE;
   \   000000B0   0x208D             MOVS     R0,#+141
   \   000000B2   0x7020             STRB     R0,[R4, #+0]
    685                       return (OS_FALSE);
   \   000000B4   0x2000             MOVS     R0,#+0
   \                     ??OSTmrStop_1:
   \   000000B6   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    686              }
    687          }
    688          #endif
    689          
    690          /*$PAGE*/
    691          /*
    692          ************************************************************************************************************************
    693          *                                      SIGNAL THAT IT'S TIME TO UPDATE THE TIMERS
    694          *
    695          * Description: This function is typically called by the ISR that occurs at the timer tick rate and is used to signal to
    696          *              OSTmr_Task() that it's time to update the timers.
    697          *
    698          * Arguments  : none
    699          *
    700          * Returns    : OS_ERR_NONE         The call was successful and the timer task was signaled.
    701          *              OS_ERR_SEM_OVF      If OSTmrSignal() was called more often than OSTmr_Task() can handle the timers.  
    702          *                                  This would indicate that your system is heavily loaded.
    703          *              OS_ERR_EVENT_TYPE   Unlikely you would get this error because the semaphore used for signaling is created 
    704          *                                  by uC/OS-II.
    705          *              OS_ERR_PEVENT_NULL  Again, unlikely you would ever get this error because the semaphore used for signaling 
    706          *                                  is created by uC/OS-II.
    707          ************************************************************************************************************************
    708          */
    709          
    710          #if OS_TMR_EN > 0

   \                                 In section .text, align 2, keep-with-next
    711          INT8U  OSTmrSignal (void)
    712          {
   \                     OSTmrSignal:
   \   00000000   0xB580             PUSH     {R7,LR}
    713              INT8U  err;
    714          
    715          
    716              err = OSSemPost(OSTmrSemSignal);
   \   00000002   0x....             LDR.N    R0,??DataTable16_2
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       OSSemPost
    717              return (err);
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    718          }
    719          #endif
    720          
    721          /*$PAGE*/
    722          /*
    723          ************************************************************************************************************************
    724          *                                               ALLOCATE AND FREE A TIMER
    725          *
    726          * Description: This function is called to allocate a timer.
    727          *
    728          * Arguments  : none
    729          *
    730          * Returns    : a pointer to a timer if one is available
    731          ************************************************************************************************************************
    732          */
    733          
    734          #if OS_TMR_EN > 0

   \                                 In section .text, align 2, keep-with-next
    735          static  OS_TMR  *OSTmr_Alloc (void)
    736          {
    737              OS_TMR *ptmr;
    738          
    739          
    740              if (OSTmrFreeList == (OS_TMR *)0) {
   \                     OSTmr_Alloc:
   \   00000000   0x....             LDR.N    R0,??DataTable16_3
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD101             BNE.N    ??OSTmr_Alloc_0
    741                  return ((OS_TMR *)0);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE012             B.N      ??OSTmr_Alloc_1
    742              }
    743              ptmr            = (OS_TMR *)OSTmrFreeList;
   \                     ??OSTmr_Alloc_0:
   \   0000000C   0x....             LDR.N    R0,??DataTable16_3
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
    744              OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
   \   00000010   0x68C1             LDR      R1,[R0, #+12]
   \   00000012   0x....             LDR.N    R2,??DataTable16_3
   \   00000014   0x6011             STR      R1,[R2, #+0]
    745              ptmr->OSTmrNext = (OS_TCB *)0;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x60C1             STR      R1,[R0, #+12]
    746              ptmr->OSTmrPrev = (OS_TCB *)0;
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x6101             STR      R1,[R0, #+16]
    747              OSTmrUsed++;
   \   0000001E   0x....             LDR.N    R1,??DataTable16_4
   \   00000020   0x8809             LDRH     R1,[R1, #+0]
   \   00000022   0x1C49             ADDS     R1,R1,#+1
   \   00000024   0x....             LDR.N    R2,??DataTable16_4
   \   00000026   0x8011             STRH     R1,[R2, #+0]
    748              OSTmrFree--;
   \   00000028   0x....             LDR.N    R1,??DataTable16_5
   \   0000002A   0x8809             LDRH     R1,[R1, #+0]
   \   0000002C   0x1E49             SUBS     R1,R1,#+1
   \   0000002E   0x....             LDR.N    R2,??DataTable16_5
   \   00000030   0x8011             STRH     R1,[R2, #+0]
    749              return (ptmr);
   \                     ??OSTmr_Alloc_1:
   \   00000032   0x4770             BX       LR               ;; return
    750          }
    751          #endif
    752          
    753          
    754          /*
    755          ************************************************************************************************************************
    756          *                                             RETURN A TIMER TO THE FREE LIST
    757          *
    758          * Description: This function is called to return a timer object to the free list of timers.
    759          *
    760          * Arguments  : ptmr     is a pointer to the timer to free
    761          *
    762          * Returns    : none
    763          ************************************************************************************************************************
    764          */
    765          
    766          #if OS_TMR_EN > 0

   \                                 In section .text, align 2, keep-with-next
    767          static  void  OSTmr_Free (OS_TMR *ptmr)
    768          {
    769              ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
   \                     OSTmr_Free:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF880 0x1031      STRB     R1,[R0, #+49]
    770              ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0xF880 0x1030      STRB     R1,[R0, #+48]
    771              ptmr->OSTmrPeriod      = 0;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x61C1             STR      R1,[R0, #+28]
    772              ptmr->OSTmrMatch       = 0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6141             STR      R1,[R0, #+20]
    773              ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6041             STR      R1,[R0, #+4]
    774              ptmr->OSTmrCallbackArg = (void *)0;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6081             STR      R1,[R0, #+8]
    775          #if OS_TMR_CFG_NAME_SIZE > 1
    776              ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
   \   0000001C   0x213F             MOVS     R1,#+63
   \   0000001E   0xF880 0x1020      STRB     R1,[R0, #+32]
    777              ptmr->OSTmrName[1]     = OS_ASCII_NUL;
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0xF880 0x1021      STRB     R1,[R0, #+33]
    778          #endif
    779          
    780              ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x6101             STR      R1,[R0, #+16]
    781              ptmr->OSTmrNext        = OSTmrFreeList;
   \   0000002C   0x....             LDR.N    R1,??DataTable16_3
   \   0000002E   0x6809             LDR      R1,[R1, #+0]
   \   00000030   0x60C1             STR      R1,[R0, #+12]
    782              OSTmrFreeList          = ptmr;
   \   00000032   0x....             LDR.N    R1,??DataTable16_3
   \   00000034   0x6008             STR      R0,[R1, #+0]
    783          
    784              OSTmrUsed--;                                       /* Update timer object statistics                              */
   \   00000036   0x....             LDR.N    R0,??DataTable16_4
   \   00000038   0x8800             LDRH     R0,[R0, #+0]
   \   0000003A   0x1E40             SUBS     R0,R0,#+1
   \   0000003C   0x....             LDR.N    R1,??DataTable16_4
   \   0000003E   0x8008             STRH     R0,[R1, #+0]
    785              OSTmrFree++;
   \   00000040   0x....             LDR.N    R0,??DataTable16_5
   \   00000042   0x8800             LDRH     R0,[R0, #+0]
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   \   00000046   0x....             LDR.N    R1,??DataTable16_5
   \   00000048   0x8008             STRH     R0,[R1, #+0]
    786          }
   \   0000004A   0x4770             BX       LR               ;; return
    787          #endif
    788          
    789          /*$PAGE*/
    790          /*
    791          ************************************************************************************************************************
    792          *                                                    INITIALIZATION
    793          *                                          INITIALIZE THE FREE LIST OF TIMERS
    794          *
    795          * Description: This function is called by OSInit() to initialize the free list of OS_TMRs.
    796          *
    797          * Arguments  : none
    798          *
    799          * Returns    : none
    800          ************************************************************************************************************************
    801          */
    802          
    803          #if OS_TMR_EN > 0

   \                                 In section .text, align 2, keep-with-next
    804          void  OSTmr_Init (void)
    805          {
   \                     OSTmr_Init:
   \   00000000   0xB580             PUSH     {R7,LR}
    806          #if OS_EVENT_NAME_SIZE > 10
    807              INT8U    err;
    808          #endif
    809              INT16U   i;
    810              OS_TMR  *ptmr1;
    811              OS_TMR  *ptmr2;
    812          
    813          
    814              OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
   \   00000002   0xF44F 0x7150      MOV      R1,#+832
   \   00000006   0x....             LDR.N    R0,??DataTable16_6
   \   00000008   0x.... 0x....      BL       OS_MemClr
    815              OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
   \   0000000C   0x2140             MOVS     R1,#+64
   \   0000000E   0x....             LDR.N    R0,??DataTable16_7
   \   00000010   0x.... 0x....      BL       OS_MemClr
    816          
    817              ptmr1 = &OSTmrTbl[0];
   \   00000014   0x....             LDR.N    R1,??DataTable16_6
    818              ptmr2 = &OSTmrTbl[1];
   \   00000016   0x....             LDR.N    R2,??DataTable16_8
    819              for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE00E             B.N      ??OSTmr_Init_0
    820                  ptmr1->OSTmrType    = OS_TMR_TYPE;
   \                     ??OSTmr_Init_1:
   \   0000001C   0x2364             MOVS     R3,#+100
   \   0000001E   0x700B             STRB     R3,[R1, #+0]
    821                  ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
   \   00000020   0x2300             MOVS     R3,#+0
   \   00000022   0xF881 0x3031      STRB     R3,[R1, #+49]
    822                  ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
   \   00000026   0x60CA             STR      R2,[R1, #+12]
    823          #if OS_TMR_CFG_NAME_SIZE > 1
    824                  ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
   \   00000028   0x233F             MOVS     R3,#+63
   \   0000002A   0xF881 0x3020      STRB     R3,[R1, #+32]
    825                  ptmr1->OSTmrName[1] = OS_ASCII_NUL;
   \   0000002E   0x2300             MOVS     R3,#+0
   \   00000030   0xF881 0x3021      STRB     R3,[R1, #+33]
    826          #endif
    827                  ptmr1++;
   \   00000034   0x3134             ADDS     R1,R1,#+52
    828                  ptmr2++;
   \   00000036   0x3234             ADDS     R2,R2,#+52
    829              }
   \   00000038   0x1C40             ADDS     R0,R0,#+1
   \                     ??OSTmr_Init_0:
   \   0000003A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003C   0x280F             CMP      R0,#+15
   \   0000003E   0xDBED             BLT.N    ??OSTmr_Init_1
    830              ptmr1->OSTmrType    = OS_TMR_TYPE;
   \   00000040   0x2064             MOVS     R0,#+100
   \   00000042   0x7008             STRB     R0,[R1, #+0]
    831              ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF881 0x0031      STRB     R0,[R1, #+49]
    832              ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x60C8             STR      R0,[R1, #+12]
    833          #if OS_TMR_CFG_NAME_SIZE > 1
    834              ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
   \   0000004E   0x203F             MOVS     R0,#+63
   \   00000050   0xF881 0x0020      STRB     R0,[R1, #+32]
    835              ptmr1->OSTmrName[1] = OS_ASCII_NUL;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF881 0x0021      STRB     R0,[R1, #+33]
    836          #endif
    837              OSTmrTime           = 0;
   \   0000005A   0x....             LDR.N    R0,??DataTable16_1
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0x6001             STR      R1,[R0, #+0]
    838              OSTmrUsed           = 0;
   \   00000060   0x....             LDR.N    R0,??DataTable16_4
   \   00000062   0x2100             MOVS     R1,#+0
   \   00000064   0x8001             STRH     R1,[R0, #+0]
    839              OSTmrFree           = OS_TMR_CFG_MAX;
   \   00000066   0x....             LDR.N    R0,??DataTable16_5
   \   00000068   0x2110             MOVS     R1,#+16
   \   0000006A   0x8001             STRH     R1,[R0, #+0]
    840              OSTmrFreeList       = &OSTmrTbl[0];
   \   0000006C   0x....             LDR.N    R0,??DataTable16_3
   \   0000006E   0x....             LDR.N    R1,??DataTable16_6
   \   00000070   0x6001             STR      R1,[R0, #+0]
    841              OSTmrSem            = OSSemCreate(1);
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x.... 0x....      BL       OSSemCreate
   \   00000078   0x....             LDR.N    R1,??DataTable16_9
   \   0000007A   0x6008             STR      R0,[R1, #+0]
    842              OSTmrSemSignal      = OSSemCreate(0);
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x.... 0x....      BL       OSSemCreate
   \   00000082   0x....             LDR.N    R1,??DataTable16_2
   \   00000084   0x6008             STR      R0,[R1, #+0]
    843          
    844          #if OS_EVENT_NAME_SIZE > 18
    845              OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
    846          #else
    847          #if OS_EVENT_NAME_SIZE > 10
    848              OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
   \   00000086   0xAA00             ADD      R2,SP,#+0
   \   00000088   0x....             LDR.N    R1,??DataTable16_10
   \   0000008A   0x....             LDR.N    R0,??DataTable16_9
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0x.... 0x....      BL       OSEventNameSet
    849          #endif
    850          #endif
    851          
    852          #if OS_EVENT_NAME_SIZE > 18
    853              OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
    854          #else
    855          #if OS_EVENT_NAME_SIZE > 10
    856              OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
   \   00000092   0xAA00             ADD      R2,SP,#+0
   \   00000094   0x....             LDR.N    R1,??DataTable16_11
   \   00000096   0x....             LDR.N    R0,??DataTable16_2
   \   00000098   0x6800             LDR      R0,[R0, #+0]
   \   0000009A   0x.... 0x....      BL       OSEventNameSet
    857          #endif
    858          #endif
    859          
    860              OSTmr_InitTask();
   \   0000009E   0x.... 0x....      BL       OSTmr_InitTask
    861          }
   \   000000A2   0xBD01             POP      {R0,PC}          ;; return
    862          #endif
    863          
    864          /*$PAGE*/
    865          /*
    866          ************************************************************************************************************************
    867          *                                          INITIALIZE THE TIMER MANAGEMENT TASK
    868          *
    869          * Description: This function is called by OSTmrInit() to create the timer management task.
    870          *
    871          * Arguments  : none
    872          *
    873          * Returns    : none
    874          ************************************************************************************************************************
    875          */
    876          
    877          #if OS_TMR_EN > 0

   \                                 In section .text, align 2, keep-with-next
    878          static  void  OSTmr_InitTask (void)
    879          {
   \                     OSTmr_InitTask:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    880          #if OS_TASK_NAME_SIZE > 6
    881              INT8U  err;
    882          #endif
    883          
    884          
    885          #if OS_TASK_CREATE_EXT_EN > 0
    886              #if OS_STK_GROWTH == 1
    887              (void)OSTaskCreateExt(OSTmr_Task,
    888                                    (void *)0,                                       /* No arguments passed to OSTmrTask()      */
    889                                    &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1],         /* Set Top-Of-Stack                        */
    890                                    OS_TASK_TMR_PRIO,
    891                                    OS_TASK_TMR_ID,
    892                                    &OSTmrTaskStk[0],                                /* Set Bottom-Of-Stack                     */
    893                                    OS_TASK_TMR_STK_SIZE,
    894                                    (void *)0,                                       /* No TCB extension                        */
    895                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
   \   00000004   0x2003             MOVS     R0,#+3
   \   00000006   0x9004             STR      R0,[SP, #+16]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9003             STR      R0,[SP, #+12]
   \   0000000C   0x2080             MOVS     R0,#+128
   \   0000000E   0x9002             STR      R0,[SP, #+8]
   \   00000010   0x....             LDR.N    R0,??DataTable16_12
   \   00000012   0x9001             STR      R0,[SP, #+4]
   \   00000014   0xF64F 0x70FD      MOVW     R0,#+65533
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0x231D             MOVS     R3,#+29
   \   0000001C   0x....             LDR.N    R2,??DataTable16_13
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x.... 0x....      ADR.W    R0,OSTmr_Task
   \   00000024   0x.... 0x....      BL       OSTaskCreateExt
   \   00000028   0x0004             MOVS     R4,R0
    896              #else
    897              (void)OSTaskCreateExt(OSTmr_Task,
    898                                    (void *)0,                                       /* No arguments passed to OSTmrTask()      */
    899                                    &OSTmrTaskStk[0],                                /* Set Top-Of-Stack                        */
    900                                    OS_TASK_TMR_PRIO,
    901                                    OS_TASK_TMR_ID,
    902                                    &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1],         /* Set Bottom-Of-Stack                     */
    903                                    OS_TASK_TMR_STK_SIZE,
    904                                    (void *)0,                                       /* No TCB extension                        */
    905                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
    906              #endif
    907          #else
    908              #if OS_STK_GROWTH == 1
    909              (void)OSTaskCreate(OSTmr_Task,
    910                                 (void *)0,
    911                                 &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1],
    912                                 OS_TASK_TMR_PRIO);
    913              #else
    914              (void)OSTaskCreate(OSTmr_Task,
    915                                 (void *)0,
    916                                 &OSTmrTaskStk[0],
    917                                 OS_TASK_TMR_PRIO);
    918              #endif
    919          #endif
    920          
    921          #if OS_TASK_NAME_SIZE > 12
    922              OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
   \   0000002A   0xAA05             ADD      R2,SP,#+20
   \   0000002C   0x....             LDR.N    R1,??DataTable16_14
   \   0000002E   0x201D             MOVS     R0,#+29
   \   00000030   0x.... 0x....      BL       OSTaskNameSet
    923          #else
    924          #if OS_TASK_NAME_SIZE > 6
    925              OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
    926          #endif
    927          #endif
    928          }
   \   00000034   0xB006             ADD      SP,SP,#+24
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    929          #endif
    930          
    931          /*$PAGE*/
    932          /*
    933          ************************************************************************************************************************
    934          *                                         INSERT A TIMER INTO THE TIMER WHEEL
    935          *
    936          * Description: This function is called to insert the timer into the timer wheel.  The timer is always inserted at the
    937          *              beginning of the list.
    938          *
    939          * Arguments  : ptmr          Is a pointer to the timer to insert.
    940          *
    941          *              type          Is either:
    942          *                               OS_TMR_LINK_PERIODIC    Means to re-insert the timer after a period expired
    943          *                               OS_TMR_LINK_DLY         Means to insert    the timer the first time
    944          *
    945          * Returns    : none
    946          ************************************************************************************************************************
    947          */
    948          
    949          #if OS_TMR_EN > 0

   \                                 In section .text, align 2, keep-with-next
    950          static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
    951          {
    952              OS_TMR       *ptmr1;
    953              OS_TMR_WHEEL *pspoke;
    954              INT16U        spoke;
    955          
    956          
    957              ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
   \                     OSTmr_Link:
   \   00000000   0x2203             MOVS     R2,#+3
   \   00000002   0xF880 0x2031      STRB     R2,[R0, #+49]
    958              if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0xD105             BNE.N    ??OSTmr_Link_0
    959                  ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
   \   0000000C   0x69C1             LDR      R1,[R0, #+28]
   \   0000000E   0x....             LDR.N    R2,??DataTable16_1
   \   00000010   0x6812             LDR      R2,[R2, #+0]
   \   00000012   0x1851             ADDS     R1,R2,R1
   \   00000014   0x6141             STR      R1,[R0, #+20]
   \   00000016   0xE00D             B.N      ??OSTmr_Link_1
    960              } else {
    961                  if (ptmr->OSTmrDly == 0) {
   \                     ??OSTmr_Link_0:
   \   00000018   0x6981             LDR      R1,[R0, #+24]
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD105             BNE.N    ??OSTmr_Link_2
    962                      ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
   \   0000001E   0x69C1             LDR      R1,[R0, #+28]
   \   00000020   0x....             LDR.N    R2,??DataTable16_1
   \   00000022   0x6812             LDR      R2,[R2, #+0]
   \   00000024   0x1851             ADDS     R1,R2,R1
   \   00000026   0x6141             STR      R1,[R0, #+20]
   \   00000028   0xE004             B.N      ??OSTmr_Link_1
    963                  } else {
    964                      ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
   \                     ??OSTmr_Link_2:
   \   0000002A   0x6981             LDR      R1,[R0, #+24]
   \   0000002C   0x....             LDR.N    R2,??DataTable16_1
   \   0000002E   0x6812             LDR      R2,[R2, #+0]
   \   00000030   0x1851             ADDS     R1,R2,R1
   \   00000032   0x6141             STR      R1,[R0, #+20]
    965                  }
    966              }
    967              spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
   \                     ??OSTmr_Link_1:
   \   00000034   0x6942             LDR      R2,[R0, #+20]
   \   00000036   0x2308             MOVS     R3,#+8
   \   00000038   0xFBB2 0xF1F3      UDIV     R1,R2,R3
   \   0000003C   0xFB01 0x2113      MLS      R1,R1,R3,R2
    968              pspoke = &OSTmrWheelTbl[spoke];
   \   00000040   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000042   0x....             LDR.N    R2,??DataTable16_7
   \   00000044   0xEB12 0x02C1      ADDS     R2,R2,R1, LSL #+3
    969          
    970              if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
   \   00000048   0x6811             LDR      R1,[R2, #+0]
   \   0000004A   0x2900             CMP      R1,#+0
   \   0000004C   0xD105             BNE.N    ??OSTmr_Link_3
    971                  pspoke->OSTmrFirst   = ptmr;
   \   0000004E   0x6010             STR      R0,[R2, #+0]
    972                  ptmr->OSTmrNext      = (OS_TMR *)0;
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x60C1             STR      R1,[R0, #+12]
    973                  pspoke->OSTmrEntries = 1;
   \   00000054   0x2101             MOVS     R1,#+1
   \   00000056   0x8091             STRH     R1,[R2, #+4]
   \   00000058   0xE006             B.N      ??OSTmr_Link_4
    974              } else {
    975                  ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
   \                     ??OSTmr_Link_3:
   \   0000005A   0x6811             LDR      R1,[R2, #+0]
    976                  pspoke->OSTmrFirst   = ptmr;
   \   0000005C   0x6010             STR      R0,[R2, #+0]
    977                  ptmr->OSTmrNext      = (void *)ptmr1;
   \   0000005E   0x60C1             STR      R1,[R0, #+12]
    978                  ptmr1->OSTmrPrev     = (void *)ptmr;
   \   00000060   0x6108             STR      R0,[R1, #+16]
    979                  pspoke->OSTmrEntries++;
   \   00000062   0x8891             LDRH     R1,[R2, #+4]
   \   00000064   0x1C49             ADDS     R1,R1,#+1
   \   00000066   0x8091             STRH     R1,[R2, #+4]
    980              }
    981              ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
   \                     ??OSTmr_Link_4:
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x6101             STR      R1,[R0, #+16]
    982          }
   \   0000006C   0x4770             BX       LR               ;; return
    983          #endif
    984          
    985          /*$PAGE*/
    986          /*
    987          ************************************************************************************************************************
    988          *                                         REMOVE A TIMER FROM THE TIMER WHEEL
    989          *
    990          * Description: This function is called to remove the timer from the timer wheel.
    991          *
    992          * Arguments  : ptmr          Is a pointer to the timer to remove.
    993          *
    994          * Returns    : none
    995          ************************************************************************************************************************
    996          */
    997          
    998          #if OS_TMR_EN > 0

   \                                 In section .text, align 2, keep-with-next
    999          static  void  OSTmr_Unlink (OS_TMR *ptmr)
   1000          {
   1001              OS_TMR        *ptmr1;
   1002              OS_TMR        *ptmr2;
   1003              OS_TMR_WHEEL  *pspoke;
   1004              INT16U         spoke;
   1005          
   1006          
   1007              spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
   \                     OSTmr_Unlink:
   \   00000000   0x6942             LDR      R2,[R0, #+20]
   \   00000002   0x2308             MOVS     R3,#+8
   \   00000004   0xFBB2 0xF1F3      UDIV     R1,R2,R3
   \   00000008   0xFB01 0x2113      MLS      R1,R1,R3,R2
   1008              pspoke = &OSTmrWheelTbl[spoke];
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0x....             LDR.N    R2,??DataTable16_7
   \   00000010   0xEB12 0x03C1      ADDS     R3,R2,R1, LSL #+3
   1009          
   1010              if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
   \   00000014   0x6819             LDR      R1,[R3, #+0]
   \   00000016   0x4281             CMP      R1,R0
   \   00000018   0xD106             BNE.N    ??OSTmr_Unlink_0
   1011                  ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
   \   0000001A   0x68C1             LDR      R1,[R0, #+12]
   1012                  pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
   \   0000001C   0x6019             STR      R1,[R3, #+0]
   1013                  if (ptmr1 != (OS_TMR *)0) {
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD008             BEQ.N    ??OSTmr_Unlink_1
   1014                      ptmr1->OSTmrPrev = (void *)0;
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x610A             STR      R2,[R1, #+16]
   \   00000026   0xE005             B.N      ??OSTmr_Unlink_1
   1015                  }
   1016              } else {
   1017                  ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
   \                     ??OSTmr_Unlink_0:
   \   00000028   0x6901             LDR      R1,[R0, #+16]
   1018                  ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
   \   0000002A   0x68C2             LDR      R2,[R0, #+12]
   1019                  ptmr1->OSTmrNext = ptmr2;
   \   0000002C   0x60CA             STR      R2,[R1, #+12]
   1020                  if (ptmr2 != (OS_TMR *)0) {
   \   0000002E   0x2A00             CMP      R2,#+0
   \   00000030   0xD000             BEQ.N    ??OSTmr_Unlink_1
   1021                      ptmr2->OSTmrPrev = (void *)ptmr1;
   \   00000032   0x6111             STR      R1,[R2, #+16]
   1022                  }
   1023              }
   1024              ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
   \                     ??OSTmr_Unlink_1:
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0xF880 0x1031      STRB     R1,[R0, #+49]
   1025              ptmr->OSTmrNext  = (void *)0;
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x60C1             STR      R1,[R0, #+12]
   1026              ptmr->OSTmrPrev  = (void *)0;
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x6101             STR      R1,[R0, #+16]
   1027              pspoke->OSTmrEntries--;
   \   00000042   0x8898             LDRH     R0,[R3, #+4]
   \   00000044   0x1E40             SUBS     R0,R0,#+1
   \   00000046   0x8098             STRH     R0,[R3, #+4]
   1028          }
   \   00000048   0x4770             BX       LR               ;; return
   1029          #endif
   1030          
   1031          /*$PAGE*/
   1032          /*
   1033          ************************************************************************************************************************
   1034          *                                       TIMER MANAGER DATA STRUCTURE LOCKING MECHANISM
   1035          *
   1036          * Description: These functions are used to gain exclusive access to timer management data structures.
   1037          *
   1038          * Arguments  : none
   1039          *
   1040          * Returns    : none
   1041          ************************************************************************************************************************
   1042          */
   1043          
   1044          #if OS_TMR_EN > 0

   \                                 In section .text, align 2, keep-with-next
   1045          static  void  OSTmr_Lock (void)
   1046          {
   \                     OSTmr_Lock:
   \   00000000   0xB580             PUSH     {R7,LR}
   1047              INT8U  err;
   1048          
   1049          
   1050              OSSemPend(OSTmrSem, 0, &err);
   \   00000002   0xAA00             ADD      R2,SP,#+0
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x....             LDR.N    R0,??DataTable16_9
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x.... 0x....      BL       OSSemPend
   1051              (void)err;
   1052          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
   1053          #endif
   1054          
   1055          
   1056          
   1057          #if OS_TMR_EN > 0

   \                                 In section .text, align 2, keep-with-next
   1058          static  void  OSTmr_Unlock (void)
   1059          {
   \                     OSTmr_Unlock:
   \   00000000   0xB580             PUSH     {R7,LR}
   1060              (void)OSSemPost(OSTmrSem);
   \   00000002   0x....             LDR.N    R0,??DataTable16_9
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       OSSemPost
   1061          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
   1062          #endif
   1063          
   1064          /*$PAGE*/
   1065          /*
   1066          ************************************************************************************************************************
   1067          *                                                 TIMER MANAGEMENT TASK
   1068          *
   1069          * Description: This task is created by OSTmrInit().
   1070          *
   1071          * Arguments  : none
   1072          *
   1073          * Returns    : none
   1074          ************************************************************************************************************************
   1075          */
   1076          
   1077          #if OS_TMR_EN > 0

   \                                 In section .text, align 4, keep-with-next
   1078          static  void  OSTmr_Task (void *p_arg)
   1079          {
   \                     OSTmr_Task:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1080              INT8U            err;
   1081              OS_TMR          *ptmr;
   1082              OS_TMR          *ptmr_next;
   1083              OS_TMR_CALLBACK  pfnct;
   1084              OS_TMR_WHEEL    *pspoke;
   1085              INT16U           spoke;
   1086          
   1087          
   1088              (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
   \   00000002   0xE001             B.N      ??OSTmr_Task_0
   1089              for (;;) {
   1090                  OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
   1091                  OSTmr_Lock();
   1092                  OSTmrTime++;                                             /* Increment the current time                        */
   1093                  spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
   1094                  pspoke = &OSTmrWheelTbl[spoke];
   1095                  ptmr   = pspoke->OSTmrFirst;
   1096                  while (ptmr != (OS_TMR *)0) {
   1097                      ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
   1098                                                                           /* ... timer could get unlinked from the wheel.      */
   1099                      if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
   1100                          pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
   1101                          if (pfnct != (OS_TMR_CALLBACK)0) {
   1102                              (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
   1103                          }
   1104                          OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
   1105                          if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
   1106                              OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
   1107                          } else {
   1108                              ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
   1109                          }
   1110                      }
   1111                      ptmr = ptmr_next;
   1112                  }
   1113                  OSTmr_Unlock();
   \                     ??OSTmr_Task_1:
   \   00000004   0x.... 0x....      BL       OSTmr_Unlock
   \                     ??OSTmr_Task_0:
   \   00000008   0xAA00             ADD      R2,SP,#+0
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x....             LDR.N    R0,??DataTable16_2
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x.... 0x....      BL       OSSemPend
   \   00000014   0x.... 0x....      BL       OSTmr_Lock
   \   00000018   0x....             LDR.N    R0,??DataTable16_1
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0x....             LDR.N    R1,??DataTable16_1
   \   00000020   0x6008             STR      R0,[R1, #+0]
   \   00000022   0x....             LDR.N    R0,??DataTable16_1
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x2208             MOVS     R2,#+8
   \   00000028   0xFBB1 0xF0F2      UDIV     R0,R1,R2
   \   0000002C   0xFB00 0x1012      MLS      R0,R0,R2,R1
   \   00000030   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000032   0x....             LDR.N    R1,??DataTable16_7
   \   00000034   0xEB11 0x00C0      ADDS     R0,R1,R0, LSL #+3
   \   00000038   0x6804             LDR      R4,[R0, #+0]
   \   0000003A   0xE003             B.N      ??OSTmr_Task_2
   \                     ??OSTmr_Task_3:
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0xF884 0x0031      STRB     R0,[R4, #+49]
   \                     ??OSTmr_Task_4:
   \   00000042   0x002C             MOVS     R4,R5
   \                     ??OSTmr_Task_2:
   \   00000044   0x2C00             CMP      R4,#+0
   \   00000046   0xD0DD             BEQ.N    ??OSTmr_Task_1
   \   00000048   0x68E5             LDR      R5,[R4, #+12]
   \   0000004A   0x....             LDR.N    R0,??DataTable16_1
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x6961             LDR      R1,[R4, #+20]
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD1F6             BNE.N    ??OSTmr_Task_4
   \   00000054   0x6862             LDR      R2,[R4, #+4]
   \   00000056   0x0010             MOVS     R0,R2
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD002             BEQ.N    ??OSTmr_Task_5
   \   0000005C   0x68A1             LDR      R1,[R4, #+8]
   \   0000005E   0x0020             MOVS     R0,R4
   \   00000060   0x4790             BLX      R2
   \                     ??OSTmr_Task_5:
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0x.... 0x....      BL       OSTmr_Unlink
   \   00000068   0xF894 0x0030      LDRB     R0,[R4, #+48]
   \   0000006C   0x2802             CMP      R0,#+2
   \   0000006E   0xD1E5             BNE.N    ??OSTmr_Task_3
   \   00000070   0x2101             MOVS     R1,#+1
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0x.... 0x....      BL       OSTmr_Link
   \   00000078   0xE7E3             B.N      ??OSTmr_Task_4
   1114              }
   1115          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x........         DC32     OSTmrTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x........         DC32     OSTmrSemSignal

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x........         DC32     OSTmrFreeList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x........         DC32     OSTmrUsed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x........         DC32     OSTmrFree

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x........         DC32     OSTmrTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x........         DC32     OSTmrWheelTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0x........         DC32     OSTmrTbl+0x34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   0x........         DC32     OSTmrSem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   0x........         DC32     `?<Constant "OS-TmrLock">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   0x........         DC32     `?<Constant "OS-TmrSig">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   0x........         DC32     OSTmrTaskStk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   0x........         DC32     OSTmrTaskStk+0x1FC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \   00000000   0x........         DC32     `?<Constant "uC/OS-II Tmr">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "OS-TmrLock">`:
   \   00000000   0x4F 0x53          DC8 "OS-TmrLock"
   \              0x2D 0x54    
   \              0x6D 0x72    
   \              0x4C 0x6F    
   \              0x63 0x6B    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "OS-TmrSig">`:
   \   00000000   0x4F 0x53          DC8 "OS-TmrSig"
   \              0x2D 0x54    
   \              0x6D 0x72    
   \              0x53 0x69    
   \              0x67 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "uC/OS-II Tmr">`:
   \   00000000   0x75 0x43          DC8 "uC/OS-II Tmr"
   \              0x2F 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \              0x20 0x54    
   \              0x6D 0x72    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1116          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   OSTmrCreate
        32   -> OSTmr_Alloc
        32   -> OSTmr_Lock
        32   -> OSTmr_Unlock
        32   -> OS_StrCopy
        32   -> OS_StrLen
      16   OSTmrDel
        16   -> OSTmr_Free
        16   -> OSTmr_Lock
        16   -> OSTmr_Unlink
        16   -> OSTmr_Unlock
      16   OSTmrNameGet
        16   -> OSTmr_Lock
        16   -> OSTmr_Unlock
        16   -> OS_StrCopy
      16   OSTmrRemainGet
        16   -> OSTmr_Lock
        16   -> OSTmr_Unlock
       8   OSTmrSignal
         8   -> OSSemPost
      16   OSTmrStart
        16   -> OSTmr_Link
        16   -> OSTmr_Lock
        16   -> OSTmr_Unlink
        16   -> OSTmr_Unlock
      16   OSTmrStateGet
        16   -> OSTmr_Lock
        16   -> OSTmr_Unlock
      24   OSTmrStop
        24   -- Indirect call
        24   -> OSTmr_Lock
        24   -> OSTmr_Unlink
        24   -> OSTmr_Unlock
       0   OSTmr_Alloc
       0   OSTmr_Free
       8   OSTmr_Init
         8   -> OSEventNameSet
         8   -> OSSemCreate
         8   -> OSTmr_InitTask
         8   -> OS_MemClr
      32   OSTmr_InitTask
        32   -> OSTaskCreateExt
        32   -> OSTaskNameSet
       0   OSTmr_Link
       8   OSTmr_Lock
         8   -> OSSemPend
      16   OSTmr_Task
        16   -- Indirect call
        16   -> OSSemPend
        16   -> OSTmr_Link
        16   -> OSTmr_Lock
        16   -> OSTmr_Unlink
        16   -> OSTmr_Unlock
       0   OSTmr_Unlink
       8   OSTmr_Unlock
         8   -> OSSemPost


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?<Constant "OS-TmrLock">
      12  ?<Constant "OS-TmrSig">
      16  ?<Constant "uC/OS-II Tmr">
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
     150  OSTmrCreate
     126  OSTmrDel
     108  OSTmrNameGet
     162  OSTmrRemainGet
      14  OSTmrSignal
     130  OSTmrStart
      76  OSTmrStateGet
     184  OSTmrStop
      52  OSTmr_Alloc
      76  OSTmr_Free
     164  OSTmr_Init
      56  OSTmr_InitTask
     110  OSTmr_Link
      16  OSTmr_Lock
     122  OSTmr_Task
      74  OSTmr_Unlink
      12  OSTmr_Unlock

 
    40 bytes in section .rodata
 1 692 bytes in section .text
 
 1 692 bytes of CODE  memory
    40 bytes of CONST memory

Errors: none
Warnings: none
